### 面向对象

##### 面向对象编程

面向对象编程聚焦于创建对象的编程范式：

- 对象：包含数据和过程的实体。
  - 数据称为**数据属性**，过程称为**方法**；方法用于对数据属性执行操作。
- **封装**：将数据和代码结合到单个对象中的机制。

##### 面向对象编程的特点

###### 数据隐藏（Data Hiding）

- **定义**：对象的数据属性对外部代码隐藏，仅允许通过对象自身的方法访问。

- 作用：

  - 防止数据被意外破坏（如非法赋值、结构篡改）。

  - 降低外部代码对对象内部结构的依赖（外部只需关注接口，无需了解实现细节）。

在 Python 中，通过命名约定（如单下划线`_attr`表示 “建议私有”、双下划线`__attr`触发名称修饰）模拟数据隐藏，虽非严格强制，但体现了封装的设计思想。

###### 对象可复用性（Object Reusability）

- **定义**：同一对象可在不同程序中复用。
- **示例**：3D 图像对象可同时用于建筑设计软件和游戏开发程序。
- **拓展**：这是面向对象 “代码复用” 优势的核心体现，通过类的封装与继承，可构建通用组件（如 UI 控件、算法模块），在多个项目中重复使用，大幅提升开发效率。

#### 面向对象技术简介

- **类(Class):** 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。
- **方法：**类中定义的函数。
- **类变量：**类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。
- **数据成员：**类变量或者实例变量用于处理类及其实例对象的相关的数据。
- **方法重写：**如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。
- **局部变量：**定义在方法中的变量，只作用于当前实例的类。
- **实例变量：**在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。
- **继承：**即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟"是一个（is-a）"关系（例图，Dog是一个Animal）。
- **实例化：**创建一个类的实例，类的具体对象。
- **对象：**通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。

#### 类与实例

##### 类（Class）

- **定义**：指定特定类型对象的数据属性和方法的代码。
- **类比**：类似房屋的蓝图或饼干模具，是创建对象的 “模板”。

- **语法：**以`class Class_name:`开头，类名通常以大写字母开头（如`Person`、`Car`）。

##### 实例（Instance）

- **定义**：从类创建的对象。
- **类比**：类似根据蓝图建造的具体房屋或具体的饼干。
- **特性**：一个类可以创建多个实例。

```python
class HouseBlueprint:  # 类（蓝图）
    def __init__(self, area):
        self.area = area  # 数据属性

# 实例（具体房屋）
house1 = HouseBlueprint(120)
house2 = HouseBlueprint(150)
```

##### 类方法

类方法的定义与 Python 普通函数定义类似，但**每个方法必须包含`self`参数**——`self`用于引用方法所操作的特定对象（即类的实例）。

```python
class Student:
    def __init__(self, name, age):
        self.name = name  # 数据属性
        self.age = age    # 数据属性
    
    def show_info(self):  # 方法，包含self参数
        print(f"Name: {self.name}, Age: {self.age}")

# 实例化对象
stu = Student("Alice", 20)
stu.show_info()  # 输出：Name: Alice, Age: 20
```

###### 类方法的调用

使用创建的实例，通过**点表示法**调用，格式为`My_instance.method()`。

- 由于`self`参数引用的是对象的特定实例，方法会作用于该实例。
- `self`的引用是**自动传递**的，无需手动传入。

```python
class Dog:
    def bark(self):
        print("Woof!")

my_dog = Dog()
my_dog.bark()  # 点表示法调用，self自动绑定到my_dog实例
```

##### 初始化方法（Initializer Method）

###### 核心定义与作用

- **定义**：创建类的实例时自动执行的方法。
- **作用**：初始化对象的数据属性，并将`self`参数绑定到刚创建的对象上。

###### 格式与位置

- **格式**：`def __init__(self):`（可根据需求添加其他参数，用于初始化属性）。
- **位置**：通常是类定义中的第一个方法。

`__init__`接收外部参数并赋值给实例属性，确保每个对象创建时都能被正确初始化，是面向对象中 “对象状态初始化” 的核心机制。

```python
class Person:
    def __init__(self, name, age):
        self.name = name  # 初始化数据属性name
        self.age = age    # 初始化数据属性age

# 实例化时自动调用__init__
p = Person("Bob", 30)
print(p.name, p.age)  # 输出：Bob 30
```

#### 属性

##### 实例属性（Instance Attribute）

- **定义**：属于类的**特定实例**的属性。
- **创建方式**：当方法通过`self`参数创建属性时生成（例如在`__init__`或其他实例方法中，通过`self.attribute = value`的形式定义）。若创建类的多个实例，**每个实例会拥有自己独立的属性集合，彼此互不干扰。**

```python
class Person:
    def __init__(self, name, age):
        self.name = name  # 实例属性，每个实例独立拥有
        self.age = age    # 实例属性，每个实例独立拥有

# 创建两个不同实例
person1 = Person("Alice", 25)
person2 = Person("Bob", 30)

# 每个实例的属性独立
print(person1.name, person1.age)  # 输出：Alice 25
print(person2.name, person2.age)  # 输出：Bob 30

# 修改其中一个实例的属性，不影响其他实例
person1.age = 26
print(person1.age)  # 输出：26
print(person2.age)  # 输出：30（未被修改）
```

##### 属性隐藏

- **实现方式**：对象的数据属性应设为私有，在属性名前添加两个下划线（`__`），例如`__sideup`。
- **原理**：在 Python 中，这一操作会触发**名称修饰**（name mangling），使属性变为 “伪私有”，外部代码无法直接访问，从而保障数据封装性，防止意外篡改。

```python
class Person:
    def __init__(self, name, age):
        self.__name = name  # 初始化私有数据属性name
        self.__age = age    # 初始化私有数据属性age
```

#### 类的模块存储

- **存储要求**：类可存储在以`.py`为后缀的模块文件中。
- **使用方式**：其他程序可通过`import`语句导入该模块，从而使用模块中的类，实现代码的组织与复用。
- **拓展**：这种方式是 Python 中大型项目代码管理的核心手段，例如将工具类封装在`utils.py`模块中，其他业务模块通过`import utils`即可复用这些类，提升代码的可维护性与复用性。

```python
# my_module.py（模块文件，存储类定义）
class Student:
    def __init__(self, student_id, name, score):
        self.student_id = student_id
        self.name = name
        self.score = score

    def get_grade(self):
        if self.score >= 90:
            return "优秀"
        elif self.score >= 80:
            return "良好"
        else:
            return "及格"

# 模块中的函数
def print_welcome():
    print("欢迎使用学生成绩管理模块！")
```

```python
# main.py（主程序文件，导入模块使用类）
# 导入整个模块
import my_module

# 调用模块中的函数
my_module.print_welcome()  # 输出：欢迎使用学生成绩管理模块！

# 使用模块中的类
s = my_module.Student(101, "王五", 85)
print(f"学生{ s.name }（ID：{s.student_id}）的成绩等级：{s.get_grade()}")  # 输出：学生王五（ID：101）的成绩等级：良好

# 导入模块中的特定类/函数
from my_module import Student, print_welcome
print_welcome()  # 输出：欢迎使用学生成绩管理模块！
s2 = Student(102, "赵六", 92)
print(f"学生{s2.name}的成绩等级：{s2.get_grade()}")  # 输出：学生赵六的成绩等级：优秀
```

#### `__str__`方法

**`__str__`方法**是用于展示对象状态的特殊方法，需返回字符串形式的对象信息。

##### 自动调用场景

- 当对象作为`print`函数的参数时，自动调用`__str__`。
- 当对象作为`str`函数的参数时，自动调用`__str__`。

```python
class BankAccount:
    def __init__(self, balance):
        self.__balance = balance

    # 定义__str__方法，返回对象状态的字符串描述
    def __str__(self):
        return f"银行账户当前余额：{self.__balance}元"

# 实例化对象
account = BankAccount(1000)

# 场景1：对象作为print参数，自动调用__str__
print(account)  # 输出：银行账户当前余额：1000元

# 场景2：对象作为str函数参数，自动调用__str__
account_str = str(account)
print(account_str)  # 输出：银行账户当前余额：1000元
```

#### 访问器方法与修改器方法

类的数据属性通常设为私有，通过**访问器方法**和**修改器方法**实现对属性的安全访问与修改，这是面向对象 “封装性” 的核心体现。

##### 访问器方法（Accessor Methods）

- **定义**：返回类属性的值，不修改属性本身。
- **作用**：为类外部代码提供安全检索属性值的途径，避免直接访问私有属性导致的数据破坏。

##### 修改器方法（Mutator Methods）

- **定义**：存储或修改数据属性的值。
- **作用**：通过方法逻辑控制属性的更新规则（如参数校验、业务逻辑嵌入），保障数据的合法性与一致性。

```python
class BankAccount:
    def __init__(self, balance):
        self.__balance = balance  # 私有属性，外部不可直接访问

    # 访问器方法：获取余额（不修改属性）
    def get_balance(self):
        return self.__balance

    # 修改器方法：存款（修改余额，包含逻辑校验）
    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
            return True
        return False

    # 修改器方法：取款（修改余额，包含逻辑校验）
    def withdraw(self, amount):
        if 0 < amount <= self.__balance:
            self.__balance -= amount
            return True
        return False

# 实例化并使用方法
account = BankAccount(1000)
print("当前余额（访问器方法）：", account.get_balance())  # 输出：1000

# 调用修改器方法更新属性
account.deposit(500)
print("存款后余额：", account.get_balance())  # 输出：1500

account.withdraw(300)
print("取款后余额：", account.get_balance())  # 输出：1200
```

#### 类设计技术：UML 图

##### UML 图定义

- **UML**：即**统一建模语言（Unified Modeling Language）**，是用于图形化描述面向对象系统的标准图表，是类设计、系统架构规划的核心工具。

##### 类的 UML 图布局

类的 UML 图以 “三部分方框” 呈现，结构如下：

<img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20251122153814836.png" alt="image-20251122153814836" style="zoom:50%;" />

- **顶部区域**：标注类名。
- **中间区域**：列出类的数据属性（如`name: str`、`age: int`）。
- **底部区域**：列出类的方法（如`get_info()`、`set_age(new_age)`）。

<img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20251122153831023.png" alt="image-20251122153831023" style="zoom: 50%;" />

#### 继承

##### 现实中的特化关系

在现实世界中，许多对象是**更通用对象的特化版本**。

- 示例：蚱蜢和蜜蜂是 “昆虫” 这一通用对象的特化类型。
  - 它们既具备昆虫的一般特征（如节肢动物结构、变态发育等），又拥有独特特性：
    - 蚱蜢能跳跃；
    - 蜜蜂能蜇刺、酿蜜、筑蜂巢。

##### 面向对象继承的类比

这种 “通用 - 特化” 的关系，对应面向对象编程中的**继承机制**：

- 子类（如 “蚱蜢类”“蜜蜂类”）继承父类（如 “昆虫类”）的通用属性与方法；
- 同时可添加自身特有的属性或方法，实现 “特化” 的业务逻辑。

##### 定义格式

可以使用`class DerivedClassName(BaseClassName)`定义一个派生类

```python
# 父类：通用的「昆虫」类（包含昆虫的共同特征）
class Insect:
    def __init__(self, name, legs=6):
        self.name = name  # 昆虫名称（通用属性）
        self.legs = legs  # 腿的数量（昆虫通用特征：6条腿）

    def metamorphosis(self):
        # 昆虫的通用行为：变态发育
        return f"{self.name} 正在经历变态发育（卵→幼虫→蛹→成虫）"

    def move(self):
        # 昆虫的通用移动方式
        return f"{self.name} 用 {self.legs} 条腿爬行"


# 子类1：特化的「蚱蜢」类（继承自 Insect，添加特有功能）
class Grasshopper(Insect):
    def __init__(self, name):
        # 调用父类的初始化方法（复用父类的 name 和 legs 属性）
        super().__init__(name, legs=6)  # 蚱蜢也是6条腿，直接复用父类默认值

    # 子类特有方法：蚱蜢的专属行为「跳跃」
    def jump(self):
        return f"{self.name} 用力蹬腿，实现远距离跳跃！"

    # 重写父类方法：蚱蜢的移动方式（除了爬行，还会跳跃）
    def move(self):
        parent_move = super().move()  # 先调用父类的 move 方法
        return f"{parent_move}，也能通过跳跃快速移动"


# 子类2：特化的「蜜蜂」类（继承自 Insect，添加特有功能）
class Bee(Insect):
    def __init__(self, name, hive):
        # 调用父类的初始化方法（复用 name 和 legs）
        super().__init__(name, legs=6)
        # 子类特有属性：蜂巢位置
        self.hive = hive

    # 子类特有方法1：蜜蜂的专属行为「蜇刺」
    def sting(self):
        return f"{self.name} 发起攻击，用毒刺蜇向目标！"

    # 子类特有方法2：蜜蜂的专属行为「酿蜜」
    def make_honey(self):
        return f"{self.name} 在 {self.hive} 蜂巢中酿造蜂蜜"

    # 重写父类方法：蜜蜂的移动方式（除了爬行，还会飞行）
    def move(self):
        return f"{self.name} 用翅膀飞行，速度比爬行快得多"
```

上述类可用如下UML图表示：

<img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20251122154442097.png" alt="image-20251122154442097" style="zoom:50%;" />

#### 多态（Polymorphism）

多态是指**对象具有呈现不同形式的能力**，即同一方法调用在不同对象上可表现出不同行为。

##### 多态行为的核心要素

- **方法重写**：在父类中定义方法，子类以 “同名” 方式重写该方法，实现特化逻辑。
- **动态绑定**：调用方法时，会根据**调用对象的实际类型**，自动匹配并执行对应子类的重写方法版本。

```python
class Insect:
    def move(self):
        return "昆虫的通用移动方式"

class Grasshopper(Insect):
    def move(self):
        return "蚱蜢：跳跃+爬行"

class Bee(Insect):
    def move(self):
        return "蜜蜂：飞行"

# 多态体现：同一方法调用，不同对象执行不同逻辑
def demonstrate_polymorphism(insect_obj):
    print(insect_obj.move())

# 实例化不同子类
grasshopper = Grasshopper()
bee = Bee()

# 调用同一函数，传入不同对象，执行不同行为
demonstrate_polymorphism(grasshopper)  # 输出：蚱蜢：跳跃+爬行
demonstrate_polymorphism(bee)          # 输出：蜜蜂：飞行
```

#####  重写`__init__`方法的逻辑

在之前的继承示例中，展示了**重写`__init__`方法**的实现方式：

- 子类`__init__`中通过`super()`调用父类的`__init__`方法，复用父类的初始化逻辑；
- 之后添加子类特有的属性或逻辑，实现 “继承 + 扩展” 的初始化行为。

```python
class Bee(Insect):
    def __init__(self, name, hive):
        # 调用父类的初始化方法（复用 name 和 legs）
        super().__init__(name, legs=6)
```

##### `isinstance`函数

多态为程序设计提供了极大的灵活性，但如果方法接收的对象**不是正确类的实例**，会触发`AttributeError`异常（例如调用了对象不存在的方法）。

###### `isinstance`函数定义与作用

`isinstance`函数用于判断一个对象是否为某个类的实例。

```python
class Animal:
    pass

class Dog(Animal):
    def bark(self):
        print("汪汪汪")

class Cat(Animal):
    def meow(self):
        print("喵喵喵")

# 实例化对象
dog = Dog()
cat = Cat()
num = 10

# 使用isinstance判断类型
print("dog是否是Dog的实例：", isinstance(dog, Dog))  # 输出：True
print("dog是否是Animal的实例：", isinstance(dog, Animal))  # 输出：True（继承关系）
print("cat是否是Dog的实例：", isinstance(cat, Dog))  # 输出：False
print("num是否是int的实例：", isinstance(num, int))  # 输出：True

# 异常示例：传入错误类型触发AttributeError
def make_sound(animal):
    if isinstance(animal, Dog):
        animal.bark()
    elif isinstance(animal, Cat):
        animal.meow()
    else:
        raise AttributeError("传入的对象不是Animal的子类实例")

make_sound(dog)  # 正常调用：输出“汪汪汪”
make_sound(cat)  # 正常调用：输出“喵喵喵”
# make_sound(num)  # 触发异常：AttributeError: 传入的对象不是Animal的子类实例
```
